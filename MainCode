#@title Stock Price Prediction with Stacked LSTM

!pip install yfinance

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM
import yfinance as yf

import seaborn as sns
sns.set_style('whitegrid')



# Download historical stock data from Yahoo Finance.

df = yf.download('AAPL', start='2015-01-01', end='2024-05-22')

data = df[['Close']]
print("Data Shape:", data.shape)
data.head()

# Data Scaling

scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Split Data into Training and Testing Sets

training_size = int(len(scaled_data) * 0.65)
train_data = scaled_data[:training_size]
test_data = scaled_data[training_size:]
print("Training data shape:", train_data.shape)
print("Testing data shape:", test_data.shape)

# Create Datasets for the LSTM Model

def create_dataset(dataset, time_step=100):
    X, y = [], []
    for i in range(len(dataset) - time_step):
        X.append(dataset[i:i+time_step, 0])
        y.append(dataset[i+time_step, 0])
    return np.array(X), np.array(y)

time_step = 100

# Create the training and test datasets
X_train, y_train = create_dataset(train_data, time_step)
X_test, y_test = create_dataset(test_data, time_step)
print("X_train shape:", X_train.shape, ", y_train shape:", y_train.shape)
print("X_test shape:", X_test.shape, ", y_test shape:", y_test.shape)

# Reshape Data for LSTM Input

X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test  = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

# Build the Stacked LSTM Model
model = Sequential()

# First LSTM layer with 50 units and return_sequences=True for stacking another LSTM layer
model.add(LSTM(units=50, return_sequences=True, input_shape=(time_step, 1)))
model.add(LSTM(units=50))
model.add(Dense(1))

# Compile the model
model.compile(loss='mean_squared_error', optimizer='adam')

model.summary()

# Train the Model

history = model.fit(X_train, y_train,
                    validation_data=(X_test, y_test),
                    epochs=100, batch_size=64,
                    verbose=1)

# Model Prediction and Evaluation
train_predict = model.predict(X_train)
test_predict = model.predict(X_test)

# Inverse transform predictions to get the original stock prices.
train_predict = scaler.inverse_transform(train_predict)
test_predict  = scaler.inverse_transform(test_predict)

# Inverse transform actual values for evaluation.
y_train_actual = scaler.inverse_transform(y_train.reshape(-1, 1))
y_test_actual  = scaler.inverse_transform(y_test.reshape(-1, 1))

# Calculate the RMSE (Root Mean Squared Error) for both training and test sets.
train_rmse = math.sqrt(mean_squared_error(y_train_actual, train_predict))
test_rmse  = math.sqrt(mean_squared_error(y_test_actual, test_predict))
print("Train RMSE: {:.2f}".format(train_rmse))
print("Test RMSE: {:.2f}".format(test_rmse))


# Plotting the Results
train_plot = np.empty_like(scaled_data)
train_plot[:, :] = np.nan
train_plot[time_step:len(train_predict)+time_step, 0] = train_predict[:, 0]

test_plot = np.empty_like(scaled_data)
test_plot[:, :] = np.nan

# For test predictions, we shift the starting point appropriately.
test_plot[training_size+time_step:len(scaled_data), 0] = test_predict[:, 0]

# Plot the results
plt.figure(figsize=(14, 7))
plt.plot(data.index, scaler.inverse_transform(scaled_data), label='Actual Data')
plt.plot(data.index, train_plot, label='Train Prediction')
plt.plot(data.index, test_plot, label='Test Prediction')
plt.xlabel('Date')
plt.ylabel('Stock Price')
plt.title('Stock Price Prediction using Stacked LSTM')
plt.legend()
plt.show()

# Future Prediction for Next 30 Days

temp_input = list(scaled_data[-time_step:].flatten())
future_output = []

for i in range(30):
    x_input = np.array(temp_input[-time_step:])
    x_input = x_input.reshape(1, time_step, 1)

    yhat = model.predict(x_input, verbose=0)
    future_output.append(yhat[0][0])
    temp_input.append(yhat[0][0])

# Inverse transform the future predictions
future_output = scaler.inverse_transform(np.array(future_output).reshape(-1, 1))
print("Future 30 Days Prediction:\n", future_output)

# Create future dates for plotting
last_date = data.index[-1]
future_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=30)

# Plot the historical data along with the future predictions.
plt.figure(figsize=(14, 7))
plt.plot(data.index, data['Close'], label='Historical Data')
plt.plot(future_dates, future_output, label='Future Prediction', marker='o')
plt.xlabel('Date')
plt.ylabel('Stock Price')
plt.title('30-Day Future Stock Price Prediction')
plt.legend()
plt.show()
